<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Rest/Spread 属性</title>
</head>
<body>
  <p>更新于2018-01-25: 此提案已达到第4阶段，并将成为ECMAScript 2018的一部分。</p>
  <hr/>
  <p>"Rest/Spread Properties"这个ECMAScript提案是由 Sebastian Markbåge 提出的：</p>
  <ul>
    <li>rest运算符(...)在对象的解构中。目前，这个运算符仅用于数组的解构和参数的定义中。</li>
    <li>spread运算符(...)在对象字面量中。目前，这个运算符只能在数组字面量、函数和函数调用中使用。</li>
  </ul>

  <br>
  <h1>1. rest运算符(...)在对象解构中</h1>
  <br>
  <p>在对象解构模式中，rest运算符(...)会把解构源中所有可枚举的属性都复制到它的操作对象中，除了对象字面量中已经存在的属性。</p>
  <script>
    const obj = {foo: 1, bar: 2, baz: 3};
    const {foo, ...rest} = obj;
      // 等同于
      // const foo = 1;
      // const rest = {bar: 2, baz: 3};
    console.log(foo);
    console.log(rest);
  </script>
  <p>如果你正在用对象的解构来处理命名参数，rest运算符能够让你获得所有剩余的参数：</p>
  <script>
    function func({param1, param2, ...rest}) { // rest 运算符
      console.log('All parameters: ', 
        {param1, param2, ...rest}); // spread 运算符
      return param1 + param2;
    }
    console.log(func({param1: 1, param2: 2, c: 3, d: 4}));
  </script>
  <br>

  <h3>1.1 语法限制</h3>
  <br>
  <p>
    在每个对象字面量的最外层，你最多只能使用一次rest运算符，并且处于对象的最后：
  </p>
  <script>
    // const {...rest, foo} = obj; // SyntaxError
    // const {foo, ...rest1, ...rest2} = obj; // SyntaxError
  </script>
  <p>当然，如果嵌套使用rest运算符，那么你可以多次使用它：</p>
  <script>
    const obj2 = {
      foo: {
        a: 1,
        b: 2,
        c: 3,
      },
      bar: 4,
      baz: 5,
    };
    const {foo: {a, ...rest1}, ...rest2} = obj2;
      // 相当于：
      // const a = 1;
      // const rest1 = {b: 2, c: 3};
      // const rest2 = {bar: 4, baz: 5};
    console.log(rest1, rest2);
  </script>
  <br>

  <h1>2. spread运算符(...)在对象字面量中</h1>
  <br>
  <p>
    在对象字面量中，spread运算符(...)将其操作对象中所有可枚举的属性插入到通过字面量创建的对象中：
  </p>
  <script>
    const obj3 = {foo: 1, bar: 2, baz: 3};
    const obj4 = {...obj3, qux: 4}
    console.log(obj4); // {foo: 1, bar: 2, baz: 3, qux: 4}
  </script>
  <p>
    请注意，即使属性键不冲突，顺序也很重要，因为对象会记录插入顺序：
  </p>
  <script>
    const obj5 = {qux: 4, ...obj3};
    console.log(obj5); // {qux: 4, foo: 1, bar: 2, baz: 3}
  </script>
  <p>
    如果属性键冲突，顺序决定哪些条目“获胜”：
  </p>
  <script>
    const obj6 = {...obj3, foo: true};
    console.log(obj6);
    const obj7 = {foo: true, ...obj3};
    console.log(obj7);
  </script>
  <br>

  <h1>3.对象spread运算符的常见用例</h1>
  <br>
  <p>
    在本节中，我们将看一些可以使用spread运算符来实现的内容。我还会展示如何通过<a href="http://exploringjs.com/es6/ch_oop-besides-classes.html#Object_assign">Object.assign()</a>来完成这些工作，这与spread运算符非常相似（我们将在后面详细比较它们）。
  </p>
  <br>

  <h3>3.1.克隆对象</h3>
  <br>
  <p>克隆对象obj中所有可枚举的属性</p>
  <script>
    const clone1 = {...obj};
    const clone2 = Object.assign({}, obj);
  </script>
  <p>
    克隆出来的对象的原型总是Object.prototype,它是通过对象字面量创建出来的对象原型的默认值：
  </p>
  <script>
    console.log(Object.getPrototypeOf(clone1) === Object.prototype); // true
    console.log(Object.getPrototypeOf(clone2) === Object.prototype); // true
    console.log(Object.getPrototypeOf({}) === Object.prototype) // true
  </script>
  <p>克隆obj对象，包括它的原型：</p>
  <script>
    const clone3 = {__proto__: Object.getPrototypeOf(obj), ...obj};
    const clone4 = Object.assign(
      Object.create(Object.getPrototypeOf(obj)), obj
    );
  </script>
  <p>
    请注意，对象字面量中的__proto__只是web浏览器中的必备功能，而不是一般javascript引擎。
  </p>
  <br>

  <h3>3.2.对象的正真克隆</h3>
  <br>
  <p>
    有时你需要彻底地复制obj对象的所有属性及其内置特性（可写、可枚举...），包括getters和setters。然而Object.assign()和spread运算符不起作用。你需要用<a href="http://speakingjs.com/es5/ch17.html#property_attributes">属性描述符</a>
  </p>
  <script>
    const clone5 = Object.defineProperties({},
      Object.getOwnPropertyDescriptors(obj));
  </script>
  <p>如果你还想保留obj的原型，你可以使用<a href="http://speakingjs.com/es5/ch17.html#Object.create">Object.create()</a>：</p>
  <script>
    const clone6 = Object.create(
      Object.getPrototypeOf(obj),
      Object.getOwnPropertyDescriptors(obj)
    );
  </script>
  <p>
    <a href="http://exploringjs.com/es2016-es2017/ch_object-getownpropertydescriptors.html">Object.getOwnPropertyDescriptors()</a>在“探索ES2016和ES2017”中进行了解释。
  </p>
  <br>

  <h3>3.3. 陷阱：克隆总是很浅</h3>
  <br>
  <p>
    请记住，那些我们所看到的所有克隆方法，只能得到浅拷贝：如果其中一个原始属性值是对象，则克隆将引用同一对象，但不会（递归地，深入地 ）克隆自己：
  </p>
  <script>
    const original = {prop: {}};
    const clone7 = Object.assign({}, original);

    console.log(original.prop === clone7.prop); // true
    original.prop.foo = 'abc';
    console.log(clone7.prop.foo); // abc
  </script>

  <hr>
  <h3>3.4. 各种其他用例</h3>
  <hr>
  <p>合并两个对象obj1和obj2：</p>
  <script>
    const merged1 = {...obj, ...obj2};
    const merged2 = Object.assign({}, obj, obj2);
    console.log(merged1, merged2);
  </script>
  <p>填写用户数据的默认值：</p>
  <script>
    const DEFAULTS = {foo: 'a', bar: 'b'};
    const userData = {foo: 1};

    const data1 = {...DEFAULTS, ...userData};
    const data2 = Object.assign({}, DEFAULTS, userData);
      // {foo: 1, bar: 'b}
    console.log(data1, data2);
  </script>
  <p>非破坏性地更新属性foo：</p>
  <script>
    const obj8 = {foo: 'a', bar: 'b'};
    const obj9 = {...obj8, foo: 1};
    const obj10 = Object.assign({}, obj8, {foo: 1});
      // {foo: 1, bar: 'b'}
    console.log(obj9, obj10);
  </script>
  <p>为对象内部属性foo和bar指定默认值：</p>
  <script>
    const userData2 = {foo: 1};
    const data3 = {foo: 'a', bar: 'b', ...userData};
    const data4 = Object.assign({}, {foo: 'a', bar: 'b'}, userData);
      // {foo: 1, bar: 'b'}
    console.log(data3, data4);
  </script>

  <br>
  <h1>4.Spreading对象与Object.assign()</h1>
  <br>
  <p>
    spread运算符和<a href="http://exploringjs.com/es6/ch_oop-besides-classes.html#Object_assign">Object.assign()</a>很相似。主要的区别在于spreading定义新的属性，而Object.assign()则是设置它们。到底什么意思会在后面解释。
  </p>
  <br>

  <h3>4.1. 使用 Object.assign() 的两种方式</h3>
  <br>
  <p>这里有使用Object.assign()的两种方式：</p>
  <p>第一种方式，破坏性地（改变现有的对象）：</p>
  <script>
    Object.assign(target, source1, source2);
  </script>
  <p>这里，target被修改;source1和source2被复制到target中。</p>
  <p>第二种方式，非破坏性地（不改变现有的对象）：</p>
  <script>
    const result = Object.assign({}, source1, source2);
  </script>
  <p>
    在这里，通过对象字面量创建一个新的空对象，并且source1和source2被复制到其中。最后，这个新对象作为结果被返回并分配。
  </p>
  <p>
    spread运算符与使用Object.assign()的第二种方法非常相似。接下来，我们来看看两者的异同。
  </p>

  <br>
  <h3>4.2. 通过“get”操作，spread和Object.assign()读取值</h3>
  <br>
  <p>
    在将它们写入目标对象之前，这两个操作都使用普通的“get”操作从源中读取属性值。结果，在这个过程中，getters变成了正常的数据属性。
  </p>
  <p>我们来看一个例子：</p>
  <script>
    const original2 = {
      get foo() {
        return 123;
      }
    };
  </script>
  <p>original已经有了getter foo（它的 <a href="http://speakingjs.com/es5/ch17.html#property_attributes">property descriptor</a>具有get和set属性）</p>
  <script>
    Object.getOwnPropertyDescriptor(original2, 'foo');
    // { get: [Function: foo], set: undefined, enumerable: true, configurable: true }
  </script>
  <p>
    但在它的克隆对象clone1和clone2中，foo是一个普通的数据属性（它的属性描述符具有value和writable属性）：
  </p>
  <script>
    const clone8 = {...original2};
    Object.getOwnPropertyDescriptor(clone8, 'foo');
    // {value: 123, writable: true, enumerable: true, configurable: true}

    const clone9 = Object.assign({}, original2);
    Object.getOwnPropertyDescriptor(clone9, 'foo');
    // {value: 123, writable: true, enumerable: true, configurable: true}
  </script>

  <br>
  <h3>4.3.spread运算符定义属性，Object.assign()设置属性</h3>
  <br>
  <p>
    spread运算符在目标对象中定义新属性，Object.assign()使用普通的“set”操作来创建它们。这有两个后果。
  </p>

  <br>
  <h5>使用setters的目标对象</h5>
  <br>
  <p>首先，Object.assigin()会触发setters，spread不会：</p>
  <script>
    Object.defineProperty(Object.prototype, 'foo', {
      set(value) {
        console.log('SET', value);
      },
    });
    const obj11 = {foo: 123};
  </script>
  <p>
    上一段代码扩展了一个由所有普通对象都继承的setter foo。
    <br>
    如果我们通过Object.assign()克隆obj，则会触发继承的setter：
  </p>
  <script>
    Object.assign({}, obj11);
    // SET 123
    // {}
  </script>
  <p>用spread就不会：</p>
  <script>
    {...obj11}
    // {foo: 123}
  </script>
  <p>Object.assign()也会在复制期间触发自己的setters，它不会覆盖它们。</p>

  <br>
  <h5>具有只读属性的目标对象</h5>
  <br>
  <p>
    其次，你可以终止Object.assign()通过继承的只读属性创建自己的属性，但不能使用spread运算符：
  </p>
  <script>
    Object.defineProperty(Object.prototype, 'bar', {
      writable: false,
      value: 'abc',
    });
  </script>
  <p>上一段代码注册了由所有普通对象继承的只读属性bar。</p>
  <p>因此，您不能再使用赋值来创建私有的属性bar（你只能在严格模式下获得例外;在宽松模式下，设置会自动失败）：</p>
  <script>
    const tmp = {};
    tmp.bar = 123;
    console.log(tmp.bar);
    // TypeError: Cannot assign to read only property 'bar'   =>  非严格模式下
  </script>
  <p>
    在下面的代码中，我们通过对象字面量成功创建了属性bar。这是有效的，因为对象字面量不设置属性，而是定义它们：
  </p>
  <script>
    const obj12 = {bar: 123};
  </script>
  <p>
    但是，Object.assign()使用赋值来创建属性，这就是为什么我们无法克隆obj的原因：
  </p>
  <script>
    Object.assign({}, obj12);
    // TypeError: Cannot assign to read only property 'bar
  </script>
  <p>通过spread运算符克隆会生效：</p>
  <script>
    {...obj12}
    // {bar: 123}
  </script>

  <br>
  <h3>4.4.spread和Object.assign()都只考虑自己的可枚举属性</h3>
  <br>
  <p>这两个操作都忽略所有继承的属性和所有不可枚举的属性。</p>
  <p>下面的obj对象继承了proto中的一个（enumerable！）属性，并自身有两个属性：</p>
  <script>
    const proto = {
      inheritedEnumerable: 1,
    };
    const obj13 = Object.create(proto, {
      ownEnumerable: {
        value: 2,
        enumerable: true,
      },
      ownNonEnumerable: {
        value: 3,
        enumerable: false,
      },
    });
  </script>
  <p>
    如果你克隆obj，结果只有属性ownEnumerable。不会复制inheritedEnumerable和ownNonEnumerable属性：
  </p>
  <script>
    {...obj13}
    // {ownEnumerable: 2}
    Object.assign({}, obj)
    // {ownEnumerable: 2}
    let data = {
      list: [
        {
          price: 20,
          city: [
            {
              name: '安徽',
              city: [
                {id: 340100, name: '合肥'},
                {id: 340200, name: '芜湖'},
                {id: 340300, name: '蚌埠'}
              ]
            }
          ]
        }
      ]
    }
  </script>
</body>
</html>